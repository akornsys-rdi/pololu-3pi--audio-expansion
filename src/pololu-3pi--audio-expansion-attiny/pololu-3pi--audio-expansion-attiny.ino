/*******************************************************************************
   %%SECTION_HEADER%%
   This header information is automatically generated by KodeUtils.

   File 'pololu-3pi--audio-expansion-attiny.ino' edited by RileyStarlight, last modified: 2022-03-03.
   This file is part of 'Pololu 3Ppi+ Audio Expansion' package, please see the readme files
   for more information about this file and this package.

   Copyright (C) 2022 by RileyStarlight <riley.garcia@akornsys-rdi.net>
   Released under the GNU General Public License

     This program is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see <http://www.gnu.org/licenses/>.

   %%EOS_HEADER%%
 ******************************************************************************/


/*******************************************************************************
   B O A R D   &   F U S E S   C O N F I G U R A T I O N
   - MCU: ATtiny85
   - Board: ATtiny25/45/85, Attiny85, Internal 16MHz
   - Fuses: Low fuse 0xE1; High fuse 0xDD; Extended fuse 0xFE
   - First run cli: `avrdude -pattiny85 -Pusb -cavrispmkII -Ulfuse:w:0xE1:m   -Uhfuse:w:0xDD:m   -Uefuse:w:0xFE:m`
   - Burn cli: `avrdude -pattiny85 -Pusb -cavrispmkII -Uflash:w:pololu-3pi--audio-expansion-attiny.ino.hex`
******************************************************************************/


/*******************************************************************************
    G P I O   C O N S T A N T S
 ******************************************************************************/
#define PWRL                    0                   // PWRL on GPIO 0 (physical pin 5), interlink bidir communication.
#define ANT                     2                   // ANT on GPIO 2 (physical pin 7), radio module reception.
#define DAT                     3                   // DAT on GPIO 3 (physical pin 2), output to WS2812B LED.
#define ID                      A2                  // ID on GPIO 4 (physical pin 3), identifier potentiometer.
// Other pins are unused.


/*******************************************************************************
    C O N S T A N T S
 ******************************************************************************/
#define N_ROBOTS                5                   // Maximum number of simultaneously active robots.
#define REMOTE_COMMAND_ON       7074148UL           // Code of the command generated by the remote control for resume.
#define REMOTE_COMMAND_OFF      7074152UL           // Code of the command generated by the remote control for pause.
#define ID_AVE_READS            4                   // Number of readings taken to average the identifier potentiometer.
#define ID_TIME_DELAY           1                   // Milliseconds to wait between correlative readings of the identifier potentiometer.
#define ID_CHANGE_THRESHOLD     5                   // Threshold ADC values to detect changes in the identifier potentiometer value.
#define ID_CHANGE_DELAY         3000                // Milliseconds of waiting during which the color of the selected identifier is held.
#define SAMD_TIMEOUT            5000                // Milliseconds to wait for communication with the ATSAMD before considering that it is not present.
#define PWRL_PULSE_TIMEOUT      10                  // Milliseconds maximum time to wait for ATSAMD pulse to be generated.
#define PWRL_PULSE_DURATION     50                  // Microsecond duration of the pulse sent by ATSAMD21 when it is ready to receive the identifier.
#define PWRL_PULSE_THRESHOLD    12                  // Microsecond threshold for detection of the pulse sent by ATSAMD21.
#define PWRL_PRE_ID_US          5                   // Microseconds to wait before starting the identifier pulse.
#define PWRL_POST_ID_US         25                  // Microseconds of waiting after the end of the identifier pulse.
#define PWRL_ID_DURATION        360                 // Microseconds total pulse duration of the pulse that sends the identifier.


/*******************************************************************************
    L I B R A R I E S
 ******************************************************************************/
// Fork from https://github.com/luelista/rc-switch/tree/feature-pcint-rebased
#include <RCSwitch.h>                               // It is necessary to edit line 55 from `RCSwitch.h` to uncomment `#define USE_PIN_CHANGE_INTERRUPT`
RCSwitch radio = RCSwitch();

#include <Adafruit_NeoPixel.h>
Adafruit_NeoPixel ws2812 = Adafruit_NeoPixel(1, DAT, NEO_GRB + NEO_KHZ800);

// Library used only for debugging, using the ATSAMD21 as a serial bridge. Its use is incompatible with the main functionality.
// https://github.com/ArminJo/ATtinySerialOut v1.1.0
//#include <ATtinySerialOut.h>                        // It is necessary to edit line 87 from `ATtinySerialOut.h` to set `TX_PIN` to `PB2`.
//#include <avr/pgmspace.h>


void setup() {
  //initTXPin();
  //Serial.println("INIT");
  pinMode(PWRL, INPUT);
  pinMode(ANT, INPUT);
  pinMode(DAT, OUTPUT);
  ws2812.begin();
}

void loop() {
  static boolean first_run_setup = true;            // Initial setup flag.
  static boolean command = false;                   // Command received by the radio receiver.
  static boolean bridge_ok = false;                 // ATSAMD21-ATtiny85 bridge correctly set flag.
  static boolean id_change = false;                 // Identifier potentiometer value change flag.
  int pot_value = 0;                                // Value read from the identifier potentiometer.
  unsigned int hue = 0;                             // Hue value calculated from an identifier.
  static unsigned int identifier = 0;               // Identifier assigned to the robot.
  static int prev_pot = 0;                          // Previous value of the identifier potentiometer.
  unsigned long pwrl_wait_timeout = 0;              // Time-out check for pulse to be received.
  unsigned long pwrl_pulse_init = 0;                // Initial time of the pulse sent by ATSAMD21.
  unsigned long pwrl_pulse_end = 0;                 // Final time of the pulse sent by ATSAMD21.
  unsigned long rx_value = 0;                       // Value read by the radio receiver.
  static unsigned long color = 0;                   // Color in 24-bit format assigned by identifier.
  static unsigned long id_change_timeout = 0;       // Time-out check to restore normal mode on the RGB LED.
  static unsigned long command_on_timeout = 0;      // Time-out check to turn off RGB LED in ON command.

  pot_value = readIdPot();
  if (first_run_setup) {
    prev_pot = pot_value;
    identifier = map(pot_value, 0 + ((360 / N_ROBOTS) / 4), 1023 - ((360 / N_ROBOTS) / 4), 0, N_ROBOTS - 1);
    hue = ((360 / N_ROBOTS) * identifier) + (360 / N_ROBOTS);
    color = calculateColor(hue);
    ws2812.setPixelColor(0, color);
    ws2812.show();
    while ((digitalRead(PWRL) == LOW) && (millis() < SAMD_TIMEOUT));
    if (digitalRead(PWRL == HIGH)) {
      while (digitalRead(PWRL) == HIGH) {
        ws2812.setPixelColor(0, (0x404040UL * ((millis() & 0x40) >> 6)));
        ws2812.show();
      }
      pwrl_wait_timeout = millis();
      while ((digitalRead(PWRL) == LOW) && (millis() - pwrl_wait_timeout < PWRL_PULSE_TIMEOUT));
      pwrl_pulse_init = micros();
      while ((digitalRead(PWRL) == HIGH) && (millis() - pwrl_wait_timeout < PWRL_PULSE_TIMEOUT));
      pwrl_pulse_end = micros();
      if ((pwrl_pulse_end - pwrl_pulse_init > (PWRL_PULSE_DURATION - PWRL_PULSE_THRESHOLD)) && (pwrl_pulse_end - pwrl_pulse_init < (PWRL_PULSE_DURATION + PWRL_PULSE_THRESHOLD))) {
        delayMicroseconds(PWRL_PRE_ID_US);
        pinMode(PWRL, OUTPUT);
        sendPulse(hue);
        delayMicroseconds(PWRL_POST_ID_US);
        ws2812.setPixelColor(0, 0, 255, 0);
        bridge_ok = true;
      }
      else {
        ws2812.setPixelColor(0, 255, 0, 0);
      }
      ws2812.show();
      delay(500);
    }
    radio.enableReceive(2);
    first_run_setup = false;
  }
  else {
    if (radio.available()) {
      rx_value = radio.getReceivedValue();
      if (rx_value == REMOTE_COMMAND_ON) {
        if (bridge_ok) digitalWrite(PWRL, HIGH);
        command = true;
        command_on_timeout = millis();
      } else if (rx_value == REMOTE_COMMAND_OFF) {
        if (bridge_ok) digitalWrite(PWRL, LOW);
        command = false;
      }
      radio.resetAvailable();
    }
    if ((pot_value < prev_pot - ID_CHANGE_THRESHOLD) || (pot_value > prev_pot + ID_CHANGE_THRESHOLD)) {
      hue = ((360 / N_ROBOTS) * map(pot_value, 0 + ((360 / N_ROBOTS) / 4), 1023 - ((360 / N_ROBOTS) / 4), 0, N_ROBOTS - 1)) + (360 / N_ROBOTS);
      ws2812.setPixelColor(0,  calculateColor(hue));
      prev_pot = pot_value;
      id_change = true;
      id_change_timeout = millis();
    }
    else {
      if (id_change) {
        if (millis() - id_change_timeout >= ID_CHANGE_DELAY) id_change = false;
      }
      else {
        if (command) {
          if (millis() - command_on_timeout <= 5000) ws2812.setPixelColor(0, color);
          else ws2812.setPixelColor(0, 0);
        }
        else ws2812.setPixelColor(0, (color * ((millis() & 0x80) >> 7)));
      }
    }
    ws2812.show();
  }
}


// Read the potentiometer of the identifier, and average the readings taken.
// Returns:
//      Value read by the ADC after averaging.
unsigned int readIdPot() {
  unsigned long read_value = 0;

  for (unsigned char i = 0; i < ID_AVE_READS; i++) {
    read_value += analogRead(ID);
    delay(ID_TIME_DELAY);
  }
  return (read_value / ID_AVE_READS);
}


// Calculates the color from the hue value.
// Required arguments:
//      Hue value (0-360).
// Returns:
//      RGB color in 24-bit format.
unsigned long calculateColor(unsigned int hue) {
  unsigned char red = 0;
  unsigned char green = 0;
  unsigned char blue = 0;
  unsigned char step = 0;
  unsigned long ret = 0;

  step = ((255UL * hue) / 60UL);
  if (hue < 61) {
    red = 255;
    green = step;
  }
  else if ((hue > 60) && (hue < 121)) {
    green = 255;
    red = 255 - step;
  }
  else if ((hue > 120) && (hue < 181)) {
    green = 255;
    blue = step;
  }
  else if ((hue > 180) && (hue < 241)) {
    blue = 255;
    green = 255 - step;
  }
  else if ((hue > 240) && (hue < 301)) {
    blue = 255;
    red = step;
  }
  else if ((hue > 300) && (hue < 361)) {
    red = 255;
    blue = 255 - step;
  }
  ret = (((unsigned long)red << 16) & 0xFF0000) | (((unsigned long)green << 8) & 0xFF00) | (blue & 0xFF);
  return ret;
}


// Generates a variable width pulse, with a total duration of 360µs.
// Required arguments:
//      Pulse duration in microseconds (0-360).
void sendPulse(unsigned int us) {
  noInterrupts();
  PORTB |= 0x01;
  delayMicroseconds(us);
  PORTB &= 0x00;
  delayMicroseconds(PWRL_ID_DURATION - us);
  interrupts();
}
